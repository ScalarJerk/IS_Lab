To encrypt a block of plaintext, we need to provide an Initialization Vector and a Key<br>
To perform AES-128 encryption and decryption, the <u>plaintext blocksize, as well as the key</u> will be <b>128 bits or 16-byte</b>.
The Initialization Vector size will be equal to the size of the plaintext blocksize, 128 bits<br>
So, we are firstly <b>generating the key and the IV randomly</b>. We are using os.urandom() method for this purpose.
This method takes as input the size in bytes. And, it generates the bytes randomly. The os.urandom() method can
generate random bytes that are R cryptographically secure. (What is entropy in cryptography?)

After generating the key and the iv, we are initializing the cipher using the AES.new0 method. This function
takes as input the key and the AES mode. As we are using the CBC mode, we need to also provide the
initialization vector as an input to the AES.new() function.

Please note that our plaintext is "Hello! Welcome to The Security Buddy !! " which is more than 16 bytes. So, the
plaintext will be divided into 16-byte blocks and the last block should be padded. We are using the pad0 method
from Grypto.Util.Padding for this purpose. This function takes the input bytes and blocksize as input and
returns the padded bytes. Please note that this method does a PKCS#7 padding.

Moreover, as the pad( function takes bytes as input, we are encoding the plaintext using the encode0 method
and providing the returned bytes as input.

Please note that if we do not pad the plaintext and instead use "ciphertext = cipheri.Q.
encrypt(plaintext1.encode0)", then the program will give an error "Data must be padded to 16-byte boundary in
CBC mode"

So, after padding the plaintext, we get padded data which is multiple of 16 bytes. We can now use the bytes as
input to cipher1.encrypt() function.